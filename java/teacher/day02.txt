this
	하나의 클래스로부터 여러 객체가 생성된다.
	각 객체별로 같은 필드를 구성하고 있고, 특정 객체의 멤버변수에
	접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
	소스코드 상에서 필드 안에 메소드를 선언할 때 한 번만 선언하고,
	그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다.
	따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게
	전달해주어야 하고, 전달된 주소값을 this라는 변수가 받는다. 따라서
	this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다.
	하지만 매번 this.을 붙이기 번거롭기 때문에 지역변수와 이름이 같지 않다면
	생략이 가능하다.
-----------------------------------------------------------------------------------------
다형성(polymorphism) - 메소드
	1. 오버로딩(Overloading)
		매개변수의 개수 혹은 타입이 서로 다르면,
		같은 이름의 메소드로 선언이 가능하다.

	2.
-----------------------------------------------------------------------------------------
상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서
	   사용하고 싶을 때
	2. 여러 클래스를 선언할 때 공통 필드가 많다면, 부모 클래스를 선언하고
	   공통 필드 선언 후 여러 클래스들에게 상속해주기 위해서

상속 문법
	class A{
		A필드
	}

	class B extends A{
		A, B필드
	}

A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

상속의 작동 원리
	자식 객체로 부모 필드에 접근하기 위해서는 당연히 부모 필드가 메모리에
	할당 되어야 한다. 하지만 자식 객체를 객체화 할 때, 자식 생성자만 호출한다.
	자식 생성자만 호출하게 되면 자식 객체는 자식 필드만 접근이 가능하게 되므로
	자식 생성자 호출 시 자동으로 부모 생성자를 먼저 호출하게 된다.
	따라서 부모 필드가 먼저 메모리에 할당된 후 자식 필드가 할당되기 때문에
	자식 객체로 부모 필드에 접근할 수 있게 된다.
	자식 플드 내에서 부모 필드에 접근할 때에는 super 키워드를 사용하고,
	부모 생성자는 super()로 작성한다.

다형성(polymorphism)
	1.
	2. 오버라이딩(재정의, Overriding)
		부모에 있는 메소드가 자식에서 수정이 필요하다면,
		똑같은 이름으로 자식에게 선언해준다.
		부모 필드에 선언된 메소드가 메모리에 먼저 할당되고,
		그 다음 자식 필드에서 재정의된 메소드가 할당된다.
		같은 이름의 저장공간은 선언될 수 없으므로,
		이미 선언된 부모의 메소드 저장공간에 자식에서 새롭게
		재정의한 코드의 주소값이 들어간다.

		예)
		int data = 10;	//부모
		data = 20;	//자식

		System.out.println(data)	//자식 객체로 접근한 메소드.
						//결과는 자식 값.
---------------------------------------------------------------------------------------
클래스 배열
	같은 타입의 객체가 여러 개 있을 때
	객체명도 여러 개이다. 이름이 여러 개이면 관리하기 어렵기 때문에
	객체 배열로 선언하여 사용한다.


클래스 배열 선언
	1. 클래스명[] 배열명 = new 클래스명[길이];
	2. 클래스명[] 배열명 = {
		new 클래스명(),
		new 클래스명(),
		new 클래스명(),
		...
	}

클래스 배열 사용
	배열명[i].필드명
	배열명[i].메소드명()
---------------------------------------------------------------------------------------
Casting
	모든 자식은 부모 타입이다.

	up casting
		부모 타입에 자식 값을 넣는 형변환

	down casting
		up casting된 객체를 자식 타입으로 형변환

왜?
	하나의 부모에서 자식은 여러 개이다.
	모든 자식을 하나로 묶기 위해서는 up casting이 필요하다.
	전달받은 자식 값의 필드를 다시 모두 사용하기 위해서는
	down casting으로 복원한다.

타입 비교(instanceof)
	a instanceof A : a객체가 A타입이면 true, 아니면 false

	예) "안녕" instanceof String : true
-------------------------------------------------------------------------
아카이브파일

	패키지 익스플로러 우클릭 > Import
	> General > Existing.... > Select Archive File....
	> 배포한 아카이브파일 더블클릭

※ 배포한 알집파일은 메모장과 한번더 압축되어 있으니
  압축을 한 번 풀어야 아카이브 파일이 나옵니다

-------------------------------------------------------------------------
추상클래스
인터페이스
마커 인터페이스(실무)
예외처리
API(배포, 임포트)
-------------------------------------------------------------------------












