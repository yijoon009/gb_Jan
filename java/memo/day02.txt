this
	하나의 클래스로부터 여러 객체가 생성된다.
	각 객체별로 같은 필드를 구성하고 있고, 특정 객체의 멤버변수에
	접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
	소스코드상에서 필드 안에 메소드를 선언할 때 한 번만 선언하고,
	그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다.
	따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게
	전달해주어야 하고, 전달된 주소값을 this라는 변수가 받는다.
	따라서 this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다.
	하지만 매번 this.을 붙이기 번거롭기 때문에 지역변수와 이름이 같지 않다면
	생략이 가능하다.
	(※자바는 단일프로세스라 this는 한개뿐)

-----------------------------

다형성(polymorphism) - 메소드 성질
	1.오버로딩(Overloading)
		매개변수의 개수 혹은 타입이 서로 다르면,
		같은 이름의 메소드로 선언이 가능하다.	




2.


---------------------------

상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서
	   사용하고 싶을 때
	2. 여러 클래스를 선언할 때 공통 필드가 많다면, 부모 클래스를 선언하고
	   공통 필드 선언 후 여러 클래스들에게 상송해주기 위해서

상속 문법
	class A{
		A필드
	}

	class B extends A{
		A, B필드
	}

A: 부모클래스, 상위클래스, 슈퍼클래스, 기반클래스
B: 자식클래스, 하위클래스, 서브클래스, 파생클래스
   구어체      교재,문헌    외국      논문

상속의 작동 원리
	자식 객체로 부모 필드에 접근하기 위해서는 당연히 부모필드가 메모리에
	할당 되어야 한다. 하지만 자식 객체를 객체화 할때, 자식 생성자만 호출한다.
	자식 생성자만 호출하게 되면 자식 객체는 자식 필드만 접근이 가능하게 되므로
	자식 생성자 호출 시 자동으로 부모 생성자를 먼저 호출하게 된다. 
	따라서 부모필드가 먼저 

다형성(polymorphism)

	1.
	2. 오버라이딩(재정의, Overriding)
		부모에 있는 메소드가 자식에서 수정이 필요하다면,
		똑같은 이름으로 자식에세 선언해준다.
		부모 필드에 선언된 메소드가 메모리에 먼저 할당되고,
		그 다음 자식필드에서 재정의된 메소드가 할당된다.
		같은 이름의 저장곤간은 선언될 수 없으므로,
		이미 선언된 부모의 메소드 저장공간에 자식에서 새롭게
		재정의한 코드의 주소값이 들어간다.

		예) int data = 10; //부모
		    date = 20;	//자식

		syso(data)	//자식 객체로 접근한 메소드.
				//결과는 자식 값.

---------------------------
클래스 배열
	같은 타입의 객체가 여러 개 있을 때
	객체명도 여러 개이다. 이름이 여러 개이면 관리하기 어렵기 때문에
	객체 배열로 선언하여 사용한다.

클래스 배열 선언
	1. 클래스명[] 배열명 = new 클래스명[길이]; (반복문 통해서 할당한다)
	2. 클래스명[] 배열명 = {
		new 클래스명(),
		new 클래스명(),
		new 클래스명(),
		...
	}

클래스 배열 사용
	배열명[i].필드명
	배열명[i].메소드명()

-------------------------
Casting
	모든 자식은 부모 타입이다.

	up casting
		부모 타입에 자식 값을 넣는 형변환
	down casting

왜?
	하나의 부모에서 자식은 여러 개이다.
	모든 자식을 하나로 묶기 우해서는 up casting이 필요하다.
	전달받은 자식 값의 필드를 다시 모두 사용하기 위해서는
	down casting으로 복원한다.

타입 비교(instanceof)
	a instanceof A: a객체가 A타입이면 true, 아니면 false
	
	예)
	"안녕" instanceof String -> true

































